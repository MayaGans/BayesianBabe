---
title: 'Advanced R: Question and Answers'
author: Maya Gans
date: '2020-04-19'
slug: advanced-r-question-and-answers
categories:
  - Tutorial
tags:
  - R
subtitle: ''
summary: ''
authors: []
lastmod: '2020-04-19T16:22:39-07:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
output:
  blogdown::html_page:
    toc: true
---


<div id="TOC">
<ul>
<li><a href="#chapter-2">Chapter 2</a><ul>
<li><a href="#copy-on-modify">2.3 Copy-on-modify</a></li>
<li><a href="#function-calls">2.3.2 Function calls</a></li>
<li><a href="#lists">2.3.3 Lists</a></li>
<li><a href="#character-vectors">2.3.5 Character vectors</a></li>
<li><a href="#object-size">2.4.1 Object size</a></li>
<li><a href="#modify-in-place">2.5.1 Modify-in-place</a></li>
</ul></li>
<li><a href="#chapter-3">Chapter 3</a><ul>
<li><a href="#scalars">3.2.1 Scalars</a></li>
<li><a href="#missing-values">3.2.3 Missing values</a></li>
<li><a href="#testing-and-coercion">3.2.4 Testing and coercion</a></li>
<li><a href="#setting-attributes">3.3.1 Setting Attributes</a></li>
<li><a href="#setnames">3.3.2 setNames</a></li>
<li><a href="#dimensions">3.3.3 Dimensions</a></li>
<li><a href="#s3-atomic-vectors">3.4 S3 atomic vectors</a></li>
<li><a href="#dates">3.4.2 Dates</a></li>
<li><a href="#lists-1">3.5.1 Lists</a></li>
<li><a href="#dataframes-and-tibbles">3.6.8 Dataframes and tibbles</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></li>
<li><a href="#chapter-4">Chapter 4</a><ul>
<li><a href="#introduction">4.1 Introduction</a></li>
<li><a href="#exercise">4.3.5 Exercise</a></li>
<li><a href="#mising-and-oob">4.3.3 Mising and OOB</a></li>
<li><a href="#logical-subsetting">4.5.8 Logical subsetting</a></li>
<li><a href="#boolean-algebra">4.5.9 Boolean algebra</a></li>
</ul></li>
</ul>
</div>

<p>An R4DS bookclub discussion and companion to <a href="https://adv-r.hadley.nz/rcpp.html#acknowledgments">Advanced R</a> and supplement to <a href="https://advanced-r-solutions.rbind.io/names-and-values.html#copy-on-modify">Advanced R Solutions</a>. <a href="https://github.com/r4ds/bookclub-Advanced_R">The repository for the group can be found here</a> – feel free to contribute answers or your own questions!</p>
<div id="chapter-2" class="section level1">
<h1>Chapter 2</h1>
<div id="copy-on-modify" class="section level2">
<h2>2.3 Copy-on-modify</h2>
<div class="question">
<p>copy-on-modify vs copy-in-place: is one more preferable in certain situations?</p>
</div>
<p>modify in place only happens when objects with a single binding get a special performance optimization and to environments.</p>
</div>
<div id="function-calls" class="section level2">
<h2>2.3.2 Function calls</h2>
<div class="question">
<p>Can we go over and break down figure in 2.3.2</p>
</div>
<p>When you create this function:</p>
<pre class="r"><code>crazyfunction &lt;- function(eh) {eh}</code></pre>
<p><code>eh</code> doesn’t exist in memory at this point.</p>
<pre class="r"><code>x &lt;- c(1,2,3)</code></pre>
<p>x exists in memory.</p>
<pre class="r"><code>z &lt;- crazyfunction(x) </code></pre>
<p><code>z</code> now points at <code>x</code>, and <code>eh</code> still doesn’t exist (except metaphorically in Canada). <code>eh</code> was created and exists WHILE <code>crazyfunction()</code> was being run, but doesn’t get saved to the global environment, so after the function is run you can’t see its memory reference.</p>
<p>The round brackets <code>(eh)</code> list the arguments, the curly brackets <code>{eh}</code> define the operation that it’s doing - and you’re assigning it to <code>crazyfunction</code>.</p>
<p><strong>R functions automatically return the result of the last expression</strong> so when you call that object (the argument <code>eh</code>) it returns the value of that argument. This is called <strong>implicit returns</strong></p>
</div>
<div id="lists" class="section level2">
<h2>2.3.3 Lists</h2>
<div class="question">
<p>When would you prefer a deep copy of a list to a shallow copy? Is this something to consider when writing functions or package development or is this more something that’s optimized behind the scenes?</p>
</div>
<p>Automagical!</p>
</div>
<div id="character-vectors" class="section level2">
<h2>2.3.5 Character vectors</h2>
<div class="question">
<p>Is there a way to clear the “global string pool”?</p>
</div>
<div class="TODO">
<p>XXX</p>
</div>
</div>
<div id="object-size" class="section level2">
<h2>2.4.1 Object size</h2>
<div class="question">
<p>I understand that <code>ALTREP</code> makes the size of <code>obj_size(1:3) == obj_size(1:100)</code> but do I need to have a better grasp than that? <a href="https://blog.revolutionanalytics.com/2017/09/altrep-preview.html">Should we go over this</a></p>
</div>
<p>It’s kind of cool to know but… Probably not.</p>
</div>
<div id="modify-in-place" class="section level2">
<h2>2.5.1 Modify-in-place</h2>
<div class="question">
<p>“When it comes to bindings, R can currently only count 0, 1, or many. That means that if an object has two bindings, and one goes away, the reference count does not go back to 1: one less than many is still many. In turn, this means that R will make copies when it sometimes doesn’t need to.”</p>
<p>Can we come up with an example of this? It seems really theoretical right now.</p>
</div>
<div class="TODO">
<p>XXX</p>
</div>
<div class="question">
<p>Can we break down this code a bit more? I’d like to really understand when and how it’s copying three times.</p>
<pre class="r"><code># dataframe of 5 columns of numbers
x &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5))
# median number for each column
medians &lt;- vapply(x, median, numeric(1))
# subtract the median of each column from each value in the column
for (i in seq_along(medians)) {
  x[[i]] &lt;- x[[i]] - medians[[i]]
}</code></pre>
</div>
<pre class="r"><code>cat(tracemem(x), &quot;\n&quot;)</code></pre>
<pre><code>&lt;0x7fdc99a6f9a8&gt; </code></pre>
<pre class="r"><code>for (i in 1:5) {
  x[[i]] &lt;- x[[i]] - medians[[i]]
}</code></pre>
<pre><code>tracemem[0x7fdc99a6f9a8 -&gt; 0x7fdc9de83e38]: 
tracemem[0x7fdc9de83e38 -&gt; 0x7fdc9de83ea8]: [[&lt;-.data.frame [[&lt;- 
tracemem[0x7fdc9de83ea8 -&gt; 0x7fdc9de83f18]: [[&lt;-.data.frame [[&lt;- 
tracemem[0x7fdc9de83f18 -&gt; 0x7fdc9de83f88]: 
tracemem[0x7fdc9de83f88 -&gt; 0x7fdc9de83ff8]: [[&lt;-.data.frame [[&lt;- 
tracemem[0x7fdc9de83ff8 -&gt; 0x7fdc9de84068]: [[&lt;-.data.frame [[&lt;- 
tracemem[0x7fdc9de84068 -&gt; 0x7fdc9de840d8]: 
tracemem[0x7fdc9de840d8 -&gt; 0x7fdc9de84148]: [[&lt;-.data.frame [[&lt;- 
tracemem[0x7fdc9de84148 -&gt; 0x7fdc9de841b8]: [[&lt;-.data.frame [[&lt;- 
tracemem[0x7fdc9de841b8 -&gt; 0x7fdc9de84228]: 
tracemem[0x7fdc9de84228 -&gt; 0x7fdc9de84298]: [[&lt;-.data.frame [[&lt;- 
tracemem[0x7fdc9de84298 -&gt; 0x7fdc9de84308]: [[&lt;-.data.frame [[&lt;- 
tracemem[0x7fdc9de84308 -&gt; 0x7fdc9de84378]: 
tracemem[0x7fdc9de84378 -&gt; 0x7fdc9de843e8]: [[&lt;-.data.frame [[&lt;- 
tracemem[0x7fdc9de843e8 -&gt; 0x7fdc9de84458]: [[&lt;-.data.frame [[&lt;- </code></pre>
<p>When we run <code>tracemem</code> on the for loop above we see each column is copied twice followed by the <code>[[&lt;-.data.frame [[&lt;-</code>, the stack trace showing exactly where the duplication occurred.</p>
<p>So what is <code>[[&lt;-.data.frame</code>? It’s a function! By looking at <code>?``[[&lt;-.data.frame`` we see this is used to &quot;extract or replace subsets of data frames.&quot; When we write</code>x[[i]] &lt;- value<code>, it's really shorthand for calling the function</code>[[&lt;-.data.frame<code>with inputs</code>x<code>,</code>i<code>, and</code>value<code>.  Now let's step into the call of this base function by running</code>debug(<code>[[&lt;-.data.frame</code>)`:</p>
<pre class="r"><code>debug(`[[&lt;-.data.frame`)</code></pre>
<p>and once inside, use <code>tracemem()</code> to find where the new values are assigned to the column:</p>
<pre class="r"><code>function (x, i, j, value) 
{
  if (!all(names(sys.call()) %in% c(&quot;&quot;, &quot;value&quot;))) 
    warning(&quot;named arguments are discouraged&quot;)
  cl &lt;- oldClass(x)
  # this is where another copy of x is made!
  class(x) &lt;- NULL</code></pre>
<pre><code> # tracemem[0x7fdc9d852a18 -&gt; 0x7fdc9c99cc08]: </code></pre>
<pre class="r"><code>nrows &lt;- .row_names_info(x, 2L)
  if (is.atomic(value) &amp;&amp; !is.null(names(value))) 
    names(value) &lt;- NULL
  if (nargs() &lt; 4L) {
    nc &lt;- length(x)
    if (!is.null(value)) {
      N &lt;- NROW(value)
      if (N &gt; nrows) 
        stop(sprintf(ngettext(N, &quot;replacement has %d row, data has %d&quot;, 
          &quot;replacement has %d rows, data has %d&quot;), N, 
          nrows), domain = NA)
      if (N &lt; nrows) 
        if (N &gt; 0L &amp;&amp; (nrows%%N == 0L) &amp;&amp; length(dim(value)) &lt;= 
          1L) 
          value &lt;- rep(value, length.out = nrows)
        else stop(sprintf(ngettext(N, &quot;replacement has %d row, data has %d&quot;, 
          &quot;replacement has %d rows, data has %d&quot;), N, 
          nrows), domain = NA)
    }
    x[[i]] &lt;- value
    if (length(x) &gt; nc) {
      nc &lt;- length(x)
      if (names(x)[nc] == &quot;&quot;) 
        names(x)[nc] &lt;- paste0(&quot;V&quot;, nc)
      names(x) &lt;- make.unique(names(x))
    }
    class(x) &lt;- cl
    return(x)
  }
  if (missing(i) || missing(j)) 
    stop(&quot;only valid calls are x[[j]] &lt;- value or x[[i,j]] &lt;- value&quot;)
  rows &lt;- attr(x, &quot;row.names&quot;)
  nvars &lt;- length(x)
  if (n &lt;- is.character(i)) {
    ii &lt;- match(i, rows)
    n &lt;- sum(new.rows &lt;- is.na(ii))
    if (n &gt; 0L) {
      ii[new.rows] &lt;- seq.int(from = nrows + 1L, length.out = n)
      new.rows &lt;- i[new.rows]
    }
    i &lt;- ii
  }
  if (all(i &gt;= 0L) &amp;&amp; (nn &lt;- max(i)) &gt; nrows) {
    if (n == 0L) {
      nrr &lt;- (nrows + 1L):nn
      if (inherits(value, &quot;data.frame&quot;) &amp;&amp; (dim(value)[1L]) &gt;= 
        length(nrr)) {
        new.rows &lt;- attr(value, &quot;row.names&quot;)[seq_len(nrr)]
        repl &lt;- duplicated(new.rows) | match(new.rows, 
          rows, 0L)
        if (any(repl)) 
          new.rows[repl] &lt;- nrr[repl]
      }
      else new.rows &lt;- nrr
    }
    x &lt;- xpdrows.data.frame(x, rows, new.rows)
    rows &lt;- attr(x, &quot;row.names&quot;)
    nrows &lt;- length(rows)
  }
  iseq &lt;- seq_len(nrows)[i]
  if (anyNA(iseq)) 
    stop(&quot;non-existent rows not allowed&quot;)
  if (is.character(j)) {
    if (&quot;&quot; %in% j) 
      stop(&quot;column name \&quot;\&quot; cannot match any column&quot;)
    jseq &lt;- match(j, names(x))
    if (anyNA(jseq)) 
      stop(gettextf(&quot;replacing element in non-existent column: %s&quot;, 
        j[is.na(jseq)]), domain = NA)
  }
  else if (is.logical(j) || min(j) &lt; 0L) 
    jseq &lt;- seq_along(x)[j]
  else {
    jseq &lt;- j
    if (max(jseq) &gt; nvars) 
      stop(gettextf(&quot;replacing element in non-existent column: %s&quot;, 
        jseq[jseq &gt; nvars]), domain = NA)
  }
  if (length(iseq) &gt; 1L || length(jseq) &gt; 1L) 
    stop(&quot;only a single element should be replaced&quot;)
  x[[jseq]][[iseq]] &lt;- value
  # here is where x is copied again!
  class(x) &lt;- cl</code></pre>
<pre><code># tracemem[0x7fdc992ae9d8 -&gt; 0x7fdc9be55258]: </code></pre>
<pre class="r"><code>  x
}</code></pre>
<p>Thus seeing exactly where the three copies are happening!</p>
</div>
</div>
<div id="chapter-3" class="section level1">
<h1>Chapter 3</h1>
<div id="scalars" class="section level2">
<h2>3.2.1 Scalars</h2>
<div class="question">
<p>Can you have <code>NA</code> in vector</p>
</div>
<p>Hell yeah!</p>
</div>
<div id="missing-values" class="section level2">
<h2>3.2.3 Missing values</h2>
<div class="question">
<p><code>NA</code> is a ‘sentinel’ value for explicit missingness - what does ‘sentinel’ mean?</p>
</div>
<p>A sentinel value (also referred to as a flag value, trip value, rogue value, signal value, or dummy data) is a special value in the context of an algorithm which uses its presence as a condition of termination. Also worth noting two NAs are not equal to each other! For instance, in C++ there’s a special character to identify the end of a string I think another example of a sentinel value might be in surveys where you sometimes see missing data or N/A coded as 999, or 9999 (or maybe just 9)</p>
<p>Another example of a sentinel value might be in surveys where you sometimes see missing data or <code>N/A</code> coded as <code>999</code>, or <code>9999</code> (or maybe just <code>9</code>). The possible values in a column of data might be:</p>
<pre class="r"><code>factor(c(1,1,1,1,2,3,3,4,4,9), levels = c(1,2,3,4,9))</code></pre>
<p>Sentinels are typically employed in situations where it’s easier/preferable to have a collection of values of the same type - represented internally using the same conventions and requiring the same amount of memory - but you also need a way to indicate a special circumstance. So like in the case of survey data you may, for example, see a variable indicating that an individual is <code>999</code> years old but the correct way to interpret that is that the data was not collected.</p>
</div>
<div id="testing-and-coercion" class="section level2">
<h2>3.2.4 Testing and coercion</h2>
<div class="question">
<p>Why does the book warn us against using <code>is.vector()</code>, <code>is.atomic()</code> and <code>is.numeric()</code>? [read docs]</p>
</div>
<ul>
<li><code>is.atomic</code> will also return true if <code>NULL</code></li>
<li><code>is.numeric</code> tests if integer or double <strong>NOT</strong> factor, Date, POSIXt, difftime</li>
<li><code>is.vector</code> will return false if it has attributes other than names</li>
</ul>
</div>
<div id="setting-attributes" class="section level2">
<h2>3.3.1 Setting Attributes</h2>
<div class="question">
<p>Working in the medical field I have to import SAS files a lot where the column names have to adhere to specific abbreviations so they’re given a label attribute for their full name. What are some other common uses for attributes?</p>
</div>
<p>Hypothesis test attributes!</p>
</div>
<div id="setnames" class="section level2">
<h2>3.3.2 setNames</h2>
<div class="question">
<p>We can use <code>setNames</code> to apply different values to each element in a vector. How do we do this for our own custom attribute? The code below does NOT work!</p>
<pre class="r"><code>my_vector &lt;- c(
  structure(1, x = &quot;firstatt_1&quot;),
  structure(2, x = &quot;firstatt_2&quot;), 
  structure(3, x = &quot;firstatt_3&quot;)
)
my_vector &lt;- setNames(my_vector, c(&quot;name_1&quot;, &quot;name_2&quot;, &quot;name_3&quot;))
# mental model: shouldn&#39;t this should return $names and $x?
attributes(my_vector)</code></pre>
<pre><code>## $names
## [1] &quot;name_1&quot; &quot;name_2&quot; &quot;name_3&quot;</code></pre>
</div>
<p>As soon as you instantiate a vector the attributes are lost. BUT we can store it as a list <em>within</em> the vector to keep them! We can create a custom attribute function and use that with <code>map</code> to add a list inside our dataframe:</p>
<pre class="r"><code>custom_attr &lt;- function(x, my_attr) {
  attr(x, &quot;x&quot;) &lt;- my_attr
  return(x)
}
as_tb &lt;- 
  tibble(
  one = c(1,2,3),
  x = c(&quot;att_1&quot;, &quot;att_2&quot;, &quot;att_3&quot;),
  with_arr = map2(one, x, ~custom_attr(.x, .y))
)
as_tb$with_arr</code></pre>
<pre><code>## [[1]]
## [1] 1
## attr(,&quot;x&quot;)
## [1] &quot;att_1&quot;
## 
## [[2]]
## [1] 2
## attr(,&quot;x&quot;)
## [1] &quot;att_2&quot;
## 
## [[3]]
## [1] 3
## attr(,&quot;x&quot;)
## [1] &quot;att_3&quot;</code></pre>
</div>
<div id="dimensions" class="section level2">
<h2>3.3.3 Dimensions</h2>
<div class="question">
<p>Because <code>NROW</code> and <code>NCOL</code> don’t return <code>NULL</code> on a one dimensional vector they just seem to me as a more flexible option. When do you <em>have</em> to use <code>ncol</code> and <code>nrow</code>?</p>
</div>
<p>It <em>may</em> be better practice to always use <code>NROW</code> and <code>NCOL</code>!</p>
<div class="question">
<p>As long as the number of rows matches the data frame, it’s also possible to have a matrix or array as a column of a data frame. (This requires a slight extension to our definition of a data frame: it’s not the <code>length()</code> of each column that must be equal, but the <code>NROW()</code>.)</p>
<pre class="r"><code>df &lt;- data.frame(x = c(1,2,3,4,5),
                 y = c(letters[1:5]))
length(df$y) == NROW(df$y)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>What’s an example of where <code>length() != NROW()</code></p>
</div>
<p>The case of a matrix!</p>
<pre class="r"><code>my_matrix &lt;- 1:6
dim(my_matrix) &lt;- c(3,2)
my_matrix</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    6</code></pre>
<pre class="r"><code>length(my_matrix) == NROW(my_matrix) # 6 != 3</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>length(my_matrix) == NCOL(my_matrix) # 6 != 2</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>The length of the matrix is <code>6</code>, and if we manipulate the dimensions of the matrix we see that the NROW is <code>3</code> and and NCOL is <code>2</code>.</p>
</div>
<div id="s3-atomic-vectors" class="section level2">
<h2>3.4 S3 atomic vectors</h2>
<div class="question">
<p>How is data type <code>typeof()</code> different from <code>class()</code>?</p>
</div>
<p>Classes are built on top of base types - they’re like special, more specific kinds of types. In fact, if a class isn’t specified then <code>class()</code> will default to either the <code>implicit class</code> or <code>typeof</code>.</p>
<p>So <code>Date</code>, <code>POSIXct</code>, and <code>difftime</code> are specific kinds of doubles, falling under its umbrella.</p>
<pre class="r"><code>lubridate::is.Date(Sys.Date())</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>is.double(Sys.Date())</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>lubridate::is.POSIXct(Sys.time())</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>is.double(Sys.time())</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>lubridate::is.difftime(as.difftime(c(&quot;0:3:20&quot;, &quot;11:23:15&quot;)))</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>is.double(as.difftime(c(&quot;0:3:20&quot;, &quot;11:23:15&quot;)))</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>But then why does <code>my_factor</code> fail to be recognized under its more general <code>integer</code> umbrella?</p>
<pre class="r"><code>my_factor &lt;- factor(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))
is.factor(my_factor)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>is.integer(my_factor)</code></pre>
<pre><code>## [1] FALSE</code></pre>
</div>
<div id="dates" class="section level2">
<h2>3.4.2 Dates</h2>
<div class="question">
<p>Why are dates calculated from January 1st, 1970?</p>
</div>
<p>Unix counts time in seconds since its official “birthday,” – called “epoch” in computing terms – which is Jan. 1, 1970. <a href="https://www.wired.com/2001/09/unix-tick-tocks-to-a-billion/">This article</a> explains that the early Unix engineers picked that date arbitrarily, because they needed to set a uniform date for the start of time, and New Year’s Day, 1970, seemed most convenient.</p>
</div>
<div id="lists-1" class="section level2">
<h2>3.5.1 Lists</h2>
<div class="question">
<p>When should you be using <code>list()</code> instead of <code>c()</code></p>
</div>
<p>It’s really contingent on the use case. In the case of adding custom classes it’s worth noting that those are lost once you <code>c()</code> those objects together!</p>
</div>
<div id="dataframes-and-tibbles" class="section level2">
<h2>3.6.8 Dataframes and tibbles</h2>
<div class="question">
<p>What does ‘lazy’ mean in terms of <code>as_tibble</code>?</p>
</div>
<p>Technically <code>lazy evaluation</code> means that expressions are not evaluated when they are bound to variables, but their evaluation is deferred until their results are needed by other computations. In this context though we think Hadley just meant that it’s treated as a character if it “looks and smells like a character”.</p>
<div class="question">
<p>The solution manual gives the answer and notes:</p>
<pre class="r"><code>df_coltypes &lt;- data.frame(
  a = c(&quot;a&quot;, &quot;b&quot;),
  b = c(TRUE, FALSE),
  c = c(1L, 0L),
  d = c(1.5, 2),
  e = c(&quot;one&quot; = 1, &quot;two&quot; = 2),
  g = factor(c(&quot;f1&quot;, &quot;f2&quot;)),
  stringsAsFactors = FALSE
)
as.matrix(df_coltypes)</code></pre>
<pre><code>##     a   b       c   d     e   g   
## one &quot;a&quot; &quot;TRUE&quot;  &quot;1&quot; &quot;1.5&quot; &quot;1&quot; &quot;f1&quot;
## two &quot;b&quot; &quot;FALSE&quot; &quot;0&quot; &quot;2.0&quot; &quot;2&quot; &quot;f2&quot;</code></pre>
<p>“Note that <code>format()</code> is applied to the characters, which gives surprising results: <code>TRUE</code> is transformed to <code>&quot; TRUE&quot;</code> (starting with a space!).”</p>
<p>…But where is the <code>format()</code> call happening? I don’t see a space!</p>
</div>
<pre class="r"><code>debug(as.matrix(df_coltypes))</code></pre>
<p>If we step into the as.matrix function we see that the values are all first converted to character, the least specific (TODO - specific is not the right word) type.</p>
<pre class="r"><code>&gt; as.matrix(df_coltypes)
debugging in: as.matrix(df_coltypes)
debug: UseMethod(&quot;as.matrix&quot;)
Browse[2]&gt; 
debugging in: as.matrix.data.frame(df_coltypes)
debug: {
    dm &lt;- dim(x)
    rn &lt;- if (rownames.force %in% FALSE) 
        NULL
    else if (rownames.force %in% TRUE || .row_names_info(x) &gt; 
        0L) 
        row.names(x)
    dn &lt;- list(rn, names(x))
    if (any(dm == 0L)) 
        return(array(NA, dim = dm, dimnames = dn))
    p &lt;- dm[2L]
    pseq &lt;- seq_len(p)
    n &lt;- dm[1L]
    X &lt;- unclass(x)
    non.numeric &lt;- non.atomic &lt;- FALSE
    all.logical &lt;- TRUE
    for (j in pseq) {
        xj &lt;- X[[j]]
        if (inherits(xj, &quot;data.frame&quot;)) 
            X[[j]] &lt;- xj &lt;- as.matrix(xj)
        j.logic &lt;- is.logical(xj)
        if (all.logical &amp;&amp; !j.logic) 
            all.logical &lt;- FALSE
        if (length(levels(xj)) &gt; 0L || !(j.logic || is.numeric(xj) || 
            is.complex(xj)) || (!is.null(cl &lt;- attr(xj, &quot;class&quot;)) &amp;&amp; 
            any(cl %in% c(&quot;Date&quot;, &quot;POSIXct&quot;, &quot;POSIXlt&quot;)))) 
            non.numeric &lt;- TRUE
        if (!is.atomic(xj) &amp;&amp; !inherits(xj, &quot;POSIXlt&quot;)) 
            non.atomic &lt;- TRUE
    }
    if (non.atomic) {
        for (j in pseq) {
            xj &lt;- X[[j]]
            if (!is.recursive(xj)) 
                X[[j]] &lt;- as.list(as.vector(xj))
        }
    }
    else if (all.logical) {
    }
    else if (non.numeric) {
        for (j in pseq) {
            if (is.character(X[[j]])) 
                next
            else if (is.logical(xj &lt;- X[[j]])) 
                xj &lt;- as.character(xj)
            else {
                miss &lt;- is.na(xj)
                xj &lt;- if (length(levels(xj))) 
                  as.vector(xj)
                else format(xj)
                is.na(xj) &lt;- miss
            }
            X[[j]] &lt;- xj
        }
    }
    collabs &lt;- as.list(dn[[2L]])
    for (j in pseq) {
        xj &lt;- X[[j]]
        dj &lt;- dim(xj)
        if (length(dj) == 2L &amp;&amp; dj[2L] &gt; 0L) {
            if (!length(dnj &lt;- colnames(xj))) 
                dnj &lt;- seq_len(dj[2L])
            collabs[[j]] &lt;- if (length(collabs)) {
                if (dj[2L] &gt; 1L) 
                  paste(collabs[[j]], dnj, sep = &quot;.&quot;)
                else if (is.character(collabs[[j]])) 
                  collabs[[j]]
                else dnj
            }
            else dnj
        }
    }
    nc &lt;- vapply(X, NCOL, numeric(1), USE.NAMES = FALSE)
    X &lt;- unlist(X, recursive = FALSE, use.names = FALSE)
    dim(X) &lt;- c(n, length(X)/n)
    dimnames(X) &lt;- list(dn[[1L]], unlist(collabs[nc &gt; 0], use.names = FALSE))
    X
}</code></pre>
<div class="TODO">
<p>We can see where <code>format()</code> is called but why does the author mention a space before “TRUE” when it is converted to a character?</p>
<pre class="r"><code>as.character(TRUE)</code></pre>
<pre><code>## [1] &quot;TRUE&quot;</code></pre>
</div>
</div>
<div id="conclusion" class="section level2">
<h2>Conclusion</h2>
<div class="question">
<p>How does vectorization make your code faster</p>
</div>
<p>All vectors are of types in R, and if you know what your data type is you don’t have to coerce to different types along the way. It’s related too to copy-on-modify, because… TODO you don’t have to copy over every row of your data as you would within a for-loop.</p>
<p>Resources:</p>
<ul>
<li><p><a href="https://speakerdeck.com/jennybc/row-oriented-workflows-in-r-with-the-tidyverse">Check out Jenny Brian’s slides</a></p></li>
<li><p><a href="https://www.noamross.net/archives/2014-04-16-vectorization-in-r-why/">Great article by Noam Ross</a></p></li>
</ul>
<div class="question">
<p>Putting it all together in a single diagram:</p>
</div>
</div>
</div>
<div id="chapter-4" class="section level1">
<h1>Chapter 4</h1>
<div id="introduction" class="section level2">
<h2>4.1 Introduction</h2>
<div class="question">
<p>&quot;There are three subsetting operators <code>[</code>. <code>[[</code>, <code>$</code>. What is the destinction between an operator and a function? When you look up the help page it brings up the same page for all three extraction methods. What are their destinctions and do their definitions change based on what you’re subsetting? Can we make a table?</p>
</div>
<div class="TODO">
<table>
<thead>
<tr class="header">
<th></th>
<th><code>[</code></th>
<th><code>[[</code></th>
<th><code>$</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>atomic</td>
<td>select any number of elements</td>
<td>extract single element</td>
<td></td>
</tr>
<tr class="even">
<td>list</td>
<td>returns a smaller list</td>
<td>single element from a list</td>
<td></td>
</tr>
<tr class="odd">
<td>matrices</td>
<td>simplifies to lowest dimensonality</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>data frame</td>
<td>subsetting a list of columns</td>
<td>subsets like matrices</td>
<td>subset column</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="exercise" class="section level2">
<h2>4.3.5 Exercise</h2>
<div class="question">
<p>The question asks to describe the <code>upper.tri</code> function - let’s dig into it!</p>
</div>
<pre class="r"><code>x &lt;- outer(1:5, 1:5, FUN = &quot;*&quot;)
upper.tri(x)</code></pre>
<pre><code>##       [,1]  [,2]  [,3]  [,4]  [,5]
## [1,] FALSE  TRUE  TRUE  TRUE  TRUE
## [2,] FALSE FALSE  TRUE  TRUE  TRUE
## [3,] FALSE FALSE FALSE  TRUE  TRUE
## [4,] FALSE FALSE FALSE FALSE  TRUE
## [5,] FALSE FALSE FALSE FALSE FALSE</code></pre>
<p>We see that it returns the upper triangle of the matrix. But I wanted to walk through how this function actually works and what is meant in the solution manual by leveraging <code>.row(dim(x)) &lt;= .col(dim(x))</code>.</p>
<div class="TODO">
<pre class="r"><code># ?upper.tri
function (x, diag = FALSE) 
{
    d &lt;- dim(x)
    # what is this part of the function doing
    if (length(d) != 2L) 
        d &lt;- dim(as.matrix(x))
    if (diag) 
      # this is our subsetting logical!
        .row(d) &lt;= .col(d)
    else .row(d) &lt; .col(d)
}</code></pre>
</div>
<p>The function <code>.row()</code> and <code>.col()</code> return a matrix of integers indicating their row number</p>
<pre class="r"><code>.row(dim(x))</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    1    1    1    1
## [2,]    2    2    2    2    2
## [3,]    3    3    3    3    3
## [4,]    4    4    4    4    4
## [5,]    5    5    5    5    5</code></pre>
<pre class="r"><code>.col(dim(x))</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    2    3    4    5
## [2,]    1    2    3    4    5
## [3,]    1    2    3    4    5
## [4,]    1    2    3    4    5
## [5,]    1    2    3    4    5</code></pre>
<pre class="r"><code>.row(dim(x)) &lt;= .col(dim(x))</code></pre>
<pre><code>##       [,1]  [,2]  [,3]  [,4] [,5]
## [1,]  TRUE  TRUE  TRUE  TRUE TRUE
## [2,] FALSE  TRUE  TRUE  TRUE TRUE
## [3,] FALSE FALSE  TRUE  TRUE TRUE
## [4,] FALSE FALSE FALSE  TRUE TRUE
## [5,] FALSE FALSE FALSE FALSE TRUE</code></pre>
</div>
<div id="mising-and-oob" class="section level2">
<h2>4.3.3 Mising and OOB</h2>
<div class="question">
<p>Let’s walk through examples of each</p>
</div>
<div class="TODO">
<h3 id="atomic">ATOMIC</h3>
<pre class="r"><code>x &lt;- c(1,2,3, NULL)
# zero length
# out of bounds
# missing</code></pre>
<h3 id="list">LIST</h3>
<pre class="r"><code>num_list &lt;- list(1,2,3)
chr_list &lt;- list(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)
# zero length
# out of bounds
# out of bounds character
# missing </code></pre>
<h3 id="null">NULL</h3>
<pre class="r"><code># zero length
# out of bounds
# missing</code></pre>
</div>
</div>
<div id="logical-subsetting" class="section level2">
<h2>4.5.8 Logical subsetting</h2>
<div class="question">
<p>“Remember to use the vector boolean operators <code>&amp;</code> and <code>|</code>, not the short-circuiting scalar operators <code>&amp;&amp;</code> and <code>||</code>, which are more useful inside if statements.”</p>
<p>Can we go over the difference between <code>&amp;</code> and <code>&amp;&amp;</code> (and <code>|</code> vs <code>||</code>) I use brute force to figure out which ones I need…</p>
</div>
<div class="TODO">
<p>XXX</p>
</div>
</div>
<div id="boolean-algebra" class="section level2">
<h2>4.5.9 Boolean algebra</h2>
<div class="question">
<p>What is a use case for reversing which with the <code>unwhich()</code> function</p>
</div>
<div class="TODO">
<p>XXX</p>
</div>
<div class="question">
<p>“<code>x[-which(y)]</code> is not equivalent to <code>x[!y]</code>: if <code>y</code> is all FALSE, <code>which(y)</code> will be <code>integer(0)</code> and <code>-integer(0)</code> is still <code>integer(0)</code>, so you’ll get no values, instead of all values.”</p>
<p>Can we come up with an example for this plugging in values for <code>x</code> and <code>y</code></p>
</div>
<div class="TODO">
<p>XXX</p>
</div>
<style>

body {
  list-style-type: none important!;
  scrollbar-color: pink;
    scrollbar-face-color: #367CD2;
    scrollbar-shadow-color: #FFFFFF;
    scrollbar-highlight-color: #FFFFFF;
    scrollbar-3dlight-color: #FFFFFF;
    scrollbar-darkshadow-color: #FFFFFF;
    scrollbar-track-color: #FFFFFF;
    scrollbar-arrow-color: #FFFFFF;
}

p {
 font-size: 15px;
}

pre {
  font-size: 15px;
}

tt {
  font-size: 15px;
}

#TOC {
    position: fixed;
    left: 2em;
    top: 12em; /* 5em is height of header, 6em brings just under */
    /* bottom: 5em; /* 5em puts us above the footer; not bad but too low when TOC is collapsed */
    font-size: 10px;
    z-index: 10000; /* Ensure we float above the header, etc. */
    border: 1px solid grey;
    border-radius: 15px;
    list-style-type: none important!;
    /* Add opacity (translucency) */
    background-color: pink;
    background-color: rgba(249, 249, 249, 0.9); /* Higher opacity (last arg) means less transparency */
}
/* Ensure the TOC height doesn't take over the screen; percentages may be higher than view port, so we use pixels */
#TOC > ul {
    max-height: 350px;
    overflow: auto; 
    padding: 2em;
}
.toctoggle {
    float: right;
}
</style>
</div>
</div>
